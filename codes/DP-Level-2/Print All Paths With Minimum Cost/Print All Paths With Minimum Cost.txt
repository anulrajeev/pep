#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<bool> vb;
typedef vector<vb> vvb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef vector<vc> vvc;
typedef pair<int, int> pii;

ll mod = 1000000009;

void _main();
int main(){

	_main();
	return 0;
}
/*
void getPath(vvi &dp, int m, int n, int i, int j, string asf)
{
	if(i==0 && j==0)
		{
			for(int k=asf.length()-1;k>=0;k--)
				cout<<asf[k];
			cout<<'
';
		}
	else
	{
		if(i==0)
			getPath(dp,m,n,i,j-1,asf+"H");
		else if(j==0)
			getPath(dp,m,n,i-1,j,asf+"V");
		else
		{
			int v = dp[i-1][j];
			int h = dp[i][j-1];
			if(h<v)
				getPath(dp,m,n,i,j-1,asf+"H");
			else if(h>v)
				getPath(dp,m,n,i-1,j,asf+"V");
			else
			{
				getPath(dp,m,n,i,j-1,asf+"H");
				getPath(dp,m,n,i-1,j,asf+"V");
			}
		}

	}
}

void minCostPath(vvi &maze)
{
	int m=maze.size(), n=maze[0].size();
	vvi dp(m, vi(n));
	dp[0][0]=maze[0][0];
	for(int j=1;j<n;j++)
		dp[0][j]=dp[0][j-1]+maze[0][j];
	for(int i=1;i<m;i++)
		dp[i][0]=dp[i-1][0]+maze[i][0];

	for(int i=1;i<m;i++)
		for(int j=1;j<n;j++)
			dp[i][j]=min(dp[i][j-1], dp[i-1][j])+maze[i][j];

	
	cout<<dp[m-1][n-1]<<'
';

	getPath(dp, m, n, m-1,n-1, "");
}

*/

struct Path
{
	string asf;
	int i,j;
	
};



void minCostPath(vvi &maze)
{
	int m=maze.size(), n=maze[0].size();
	vvi dp(m, vi(n, 0));
	
	dp[m-1][n-1]=maze[m-1][n-1];
	for(int j=n-2;j>=0;j--)
		dp[m-1][j]=dp[m-1][j+1]+maze[m-1][j];
	for(int i=m-2;i>=0;i--)
		dp[i][n-1]=dp[i+1][n-1]+maze[i][n-1];
	for(int i=m-2;i>=0;i--)
		for(int j=n-2;j>=0;j--)
			dp[i][j]=min(dp[i][j+1], dp[i+1][j])+maze[i][j];



	cout<<dp[0][0]<<'
';

	queue<Path> q;
	q.push({"",0,0});
	while(q.size())
	{
		string asf = q.front().asf;
		int i=q.front().i, j=q.front().j;
		q.pop();

		if(i==m-1 && j==n-1)
			cout<<asf<<'
';
		else
		{
			if(i==m-1)
				q.push({asf+"H", i, j+1});
			else if(j==n-1)
				q.push({asf+"V", i+1, j});
			else
			{
				int h=dp[i][j+1], v=dp[i+1][j];
				if(h<v)
					q.push({asf+"H", i, j+1});
				else if(h>v)
					q.push({asf+"V", i+1, j});
				else
				{
					q.push({asf+"V", i+1, j});
					q.push({asf+"H", i, j+1});
				}




			}

		}
	}


}

void _main()
{
  	int m,n;
  	cin>>m>>n;
  	vvi maze(m, vi(n));
  	for(int i=0;i<m;i++)
  		for(int j=0;j<n;j++)
  			cin>>maze[i][j];
  	minCostPath(maze);
}