	#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<bool> vb;
typedef vector<vb> vvb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef vector<vc> vvc;
typedef pair<int, int> pii;

ll mod = 1000000009;

void _main();
int main(){

	_main();
	return 0;
}

void display(vvi &grid)
{
	int n=grid.size();
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		  if(grid[i][j])
			cout<<i<<"-"<<j<<", ";
	}
	cout<<".
";
}

void solveSudoku(vvi &grid, int n, int row, int col, int ndiag, int rdiag)
{
	if(row==n)
		display(grid);
	else
		for(int j=0;j<n;j++)
			if(
				((col&(1<<j))==0) &&
				((ndiag&(1<<(row+j)))==0) &&
				((rdiag&(1<<(row-j+n-1)))==0)
				)
			{
				grid[row][j]=1;
				// col[j]=ndiag[row+j]=rdiag[row-j+n-1]=1;
				col^=(1<<j);
				ndiag^=(1<<(row+j));
				rdiag^=(1<<(row-j+n-1));
				solveSudoku(grid,n,row+1,col,ndiag,rdiag);
				// grid[row][j]=col[j]=ndiag[row+j]=rdiag[row-j+n-1]=0;grid[row][j]=1;
				grid[row][j]=0;
				col^=(1<<j);
				ndiag^=(1<<(row+j));
				rdiag^=(1<<(row-j+n-1));
				

			}
}

void _main()
{
	int n;
	cin>>n;
	vvi grid(n, vi(n, 0));
	// int col[n]={0}, ndiag[2*n-1]={0}, rdiag[2*n-1]={0};

	solveSudoku(grid,n,0,0,0,0);


}
// using branch and bound method for optimisation instead of using the col, ndiag and rdiag arrays, we just use the numbers and the corresponding bits to indicate if the corresponding row/ diagonal is safe to occupy or already occupied